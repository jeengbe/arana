diff --git a/node_modules/madge/bin/cli.js b/node_modules/madge/bin/cli.js
index d8f14cd..0fd9bae 100644
--- a/node_modules/madge/bin/cli.js
+++ b/node_modules/madge/bin/cli.js
@@ -115,7 +115,7 @@ if (config.tsConfig) {
 	const ts = require('typescript');
 	const tsParsedConfig = ts.readJsonConfigFile(config.tsConfig, ts.sys.readFile);
 	const obj = ts.parseJsonSourceFileConfigFileContent(tsParsedConfig, ts.sys, path.dirname(config.tsConfig));
-	config.tsConfig = obj.raw;
+	// config.tsConfig = obj.raw;
 }
 
 if (program.includeNpm) {
diff --git a/node_modules/madge/lib/api.js b/node_modules/madge/lib/api.js
index 76a989e..a179e1c 100644
--- a/node_modules/madge/lib/api.js
+++ b/node_modules/madge/lib/api.js
@@ -23,7 +23,8 @@ const defaultConfig = {
 	nodeStyle: 'rounded',
 	noDependencyColor: '#cfffac',
 	cyclicNodeColor: '#ff6c60',
-	edgeColor: '#757575',
+  edgeColor: '#757575',
+  hoverEdgeColor: '#f9c5d7',
 	graphVizOptions: false,
 	graphVizPath: false,
 	dependencyFilter: false
diff --git a/node_modules/madge/lib/graph.js b/node_modules/madge/lib/graph.js
index 29032ea..689c4d9 100644
--- a/node_modules/madge/lib/graph.js
+++ b/node_modules/madge/lib/graph.js
@@ -79,39 +79,89 @@ function createGraphvizOptions(config) {
  * @return {Promise}
  */
 function createGraph(modules, circular, config, options) {
-	const g = graphviz.digraph('G');
-	const nodes = {};
-	const cyclicModules = circular.reduce((a, b) => a.concat(b), []);
-
-	if (config.graphVizPath) {
-		g.setGraphVizPath(config.graphVizPath);
-	}
-
-	Object.keys(modules).forEach((id) => {
-		nodes[id] = nodes[id] || g.addNode(id);
-
-		if (!modules[id].length) {
-			setNodeColor(nodes[id], config.noDependencyColor);
-		} else if (cyclicModules.indexOf(id) >= 0) {
-			setNodeColor(nodes[id], config.cyclicNodeColor);
-		}
-
-		modules[id].forEach((depId) => {
-			nodes[depId] = nodes[depId] || g.addNode(depId);
-
-			if (!modules[depId]) {
-				setNodeColor(nodes[depId], config.noDependencyColor);
-			}
-
-			g.addEdge(nodes[id], nodes[depId]);
-		});
-	});
-
-	return new Promise((resolve, reject) => {
-		g.output(options, resolve, (code, out, err) => {
-			reject(new Error(err));
-		});
-	});
+  const g = graphviz.digraph('madge');
+  const nodes = {};
+  const cyclicModules = circular.reduce((a, b) => a.concat(b), []);
+
+  if (config.graphVizPath) {
+    g.setGraphVizPath(config.graphVizPath);
+  }
+
+  const nodeIndices = {};
+  const edgeIndices = {};
+  // Graphviz starts counting at one
+  let nodeIndex = 1;
+  let edgeIndex = 1;
+
+  Object.keys(modules).forEach((id) => {
+    if (!nodes[id]) {
+      nodeIndices[id] = nodeIndex++;
+    }
+    nodes[id] = nodes[id] || g.addNode(id);
+
+    if (!modules[id].length) {
+      setNodeColor(nodes[id], config.noDependencyColor);
+    } else if (cyclicModules.indexOf(id) >= 0) {
+      setNodeColor(nodes[id], config.cyclicNodeColor);
+    }
+
+    modules[id].forEach((depId) => {
+      if (!nodes[depId]) {
+        nodeIndices[depId] = nodeIndex++;
+      }
+
+      nodes[depId] = nodes[depId] || g.addNode(depId);
+
+      if (!modules[depId]) {
+        setNodeColor(nodes[depId], config.noDependencyColor);
+      }
+
+      g.addEdge(nodes[id], nodes[depId]);
+      edgeIndices[id] = edgeIndices[id] || {};
+      edgeIndices[id][depId] = edgeIndex++;
+    });
+  });
+
+  let hoverStyles = Object.entries(edgeIndices).map(([id, deps]) => {
+    return Object.entries(deps)
+      .map(
+        ([depId, edgeId]) => `#node${nodeIndices[depId]}:hover~#edge${edgeId}>path {
+stroke: ${config.hoverEdgeColor};
+}
+#node${nodeIndices[depId]}:hover~#edge${edgeId}>polygon {
+stroke: ${config.hoverEdgeColor};
+fill: ${config.hoverEdgeColor};
+}
+#node${nodeIndices[id]}:hover~#edge${edgeId}>path {
+stroke: ${config.hoverEdgeColor};
+}
+#node${nodeIndices[id]}:hover~#edge${edgeId}>polygon {
+stroke: ${config.hoverEdgeColor};
+fill: ${config.hoverEdgeColor};
+}`)
+      .join('');
+  }).join('');
+
+  hoverStyles = `<style>
+${hoverStyles}
+</style>
+`;
+
+  return new Promise((resolve, reject) => {
+    g.output(options, (rendered) => {
+      if (options.type === 'svg') {
+        const svgFooter = '</svg>\n\n';
+        const __b = Buffer.alloc(rendered.length + hoverStyles.length);
+        rendered.copy(__b, 0, 0, rendered.length - svgFooter.length);
+        __b.write(hoverStyles + svgFooter, rendered.length - svgFooter.length);
+        resolve(__b);
+      } else {
+        resolve(rendered);
+      }
+    }, (code, out, err) => {
+      reject(new Error(err));
+    });
+  });
 }
 
 /**
